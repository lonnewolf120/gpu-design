<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chapter 5: Instruction Set Architecture (ISA) | Create Your Own GPU</title>
    <link rel="stylesheet" href="../styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        .chapter-content { max-width: 800px; margin: 0 auto; padding: 40px 20px; }
        .chapter-nav { display: flex; justify-content: space-between; margin: 40px 0; padding: 20px; background: var(--panel); border-radius: var(--radius); }
        .figure { margin: 30px 0; padding: 20px; background: #f9f9ff; border-radius: 12px; }
        .figure-caption { font-style: italic; color: var(--muted); margin: 10px 0 0 0; text-align: center; }
        .key-takeaway { background: #e8f4fd; border-left: 4px solid #2196f3; padding: 16px; margin: 24px 0; }
        .exercise { background: #fff3e0; border-left: 4px solid #ff9800; padding: 16px; margin: 24px 0; }
        .engineer-note { background: #f3e5f5; border-left: 4px solid #9c27b0; padding: 16px; margin: 24px 0; }
        .code-block { background: #1e1e1e; color: #d4d4d4; padding: 20px; border-radius: 8px; overflow-x: auto; margin: 20px 0; font-family: 'Consolas', 'Monaco', monospace; font-size: 14px; }
        .mermaid { background: transparent; text-align: center; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background: #f5f5f5; font-weight: bold; }
        .instruction-format { font-family: monospace; background: #f1f5f9; padding: 20px; border-radius: 8px; text-align: center; }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="chapter-nav">
            <a href="chapter-04.html">← Previous: Core Components</a>
            <a href="../table-of-contents.html">Table of Contents</a>
            <a href="chapter-06.html">Next: Pipeline Design →</a>
        </div>

        <h1>Chapter 5: Instruction Set Architecture (ISA)</h1>
        
        <div class="meta" style="color: var(--muted); margin: 20px 0;">
            <span>Part I: GPU Fundamentals</span> • 
            <span>Reading time: ~55 min</span>
        </div>

        <h2>Introduction</h2>
        <p>
            The <strong>Instruction Set Architecture (ISA)</strong> is the contract between software and hardware. 
            It defines what instructions the GPU can execute, how they're encoded, and what registers are available.
        </p>

        <div class="key-takeaway">
            <strong>Why ISA Matters:</strong> Once you tape out silicon with an ISA, you're stuck with it forever 
            for backward compatibility. We'll design a practical, minimal GPU ISA inspired by NVIDIA PTX, AMD GCN, and RISC-V.
        </div>

        <h2>5.1 ISA Design Principles</h2>

        <div class="figure">
            <div class="mermaid">
mindmap
    root((ISA Design<br/>Principles))
        RISC Philosophy
            Simple instructions
            Fixed-length encoding
            Load/Store architecture
        GPU Specific
            SIMT execution
            Thread-local registers
            Predication support
            Atomic operations
        Performance
            Large register set
            Orthogonal operations
            Efficient encoding
            </div>
            <div class="figure-caption">Figure 5.1: Key ISA design principles for GPUs</div>
        </div>

        <table>
            <thead>
                <tr>
                    <th>Principle</th>
                    <th>Description</th>
                    <th>Benefit</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Simple instructions</strong></td>
                    <td>Each instruction does one thing</td>
                    <td>Easier to pipeline</td>
                </tr>
                <tr>
                    <td><strong>Load/store architecture</strong></td>
                    <td>Only LOAD/STORE access memory</td>
                    <td>Clean separation</td>
                </tr>
                <tr>
                    <td><strong>Fixed-length instructions</strong></td>
                    <td>All instructions same bit width</td>
                    <td>Simpler decode</td>
                </tr>
                <tr>
                    <td><strong>Large register set</strong></td>
                    <td>Many registers to avoid memory</td>
                    <td>Higher performance</td>
                </tr>
            </tbody>
        </table>

        <h2>5.2 Our GPU ISA: TinyGPU-ISA</h2>

        <p>
            We'll design <strong>TinyGPU-ISA</strong> with:
        </p>
        <ul>
            <li>16-bit instruction encoding (compact, easy to implement)</li>
            <li>16 registers (R0-R12 writable, R13-R15 read-only special)</li>
            <li>11 core instructions</li>
        </ul>

        <h3>Instruction Format</h3>

        <div class="figure">
            <div class="mermaid">
block-beta
    columns 16
    
    block:OP["OPCODE"]:4
        O0["15"] O1["14"] O2["13"] O3["12"]
    end
    
    block:DST["DST"]:4
        D0["11"] D1["10"] D2["9"] D3["8"]
    end
    
    block:SRC1["SRC1"]:4
        S10["7"] S11["6"] S12["5"] S13["4"]
    end
    
    block:SRC2["SRC2"]:4
        S20["3"] S21["2"] S22["1"] S23["0"]
    end
    
    style OP fill:#dbeafe,stroke:#3b82f6
    style DST fill:#dcfce7,stroke:#22c55e
    style SRC1 fill:#fef3c7,stroke:#f59e0b
    style SRC2 fill:#fce7f3,stroke:#ec4899
            </div>
            <div class="figure-caption">Figure 5.2: 16-bit instruction format — OPCODE | DST | SRC1 | SRC2</div>
        </div>

        <div class="instruction-format">
            <strong>Format:</strong> OPCODE[15:12] | DST[11:8] | SRC1[7:4] | SRC2[3:0]<br>
            <em>Example:</em> ADD R1, R2, R3 → 0x0123
        </div>

        <h3>Register Set</h3>

        <div class="figure">
            <div class="mermaid">
flowchart LR
    subgraph GP["General Purpose (Read/Write)"]
        R0["R0"] ~~~ R1["R1"] ~~~ R2["..."] ~~~ R12["R12"]
    end
    
    subgraph SPECIAL["Special (Read-Only)"]
        R13["R13<br/>%threadIdx"]
        R14["R14<br/>%blockDim"]
        R15["R15<br/>%blockIdx"]
    end
    
    style GP fill:#dcfce7,stroke:#22c55e
    style SPECIAL fill:#fef3c7,stroke:#f59e0b
            </div>
            <div class="figure-caption">Figure 5.3: Register set — 13 general purpose + 3 special</div>
        </div>

        <table>
            <thead>
                <tr>
                    <th>Register</th>
                    <th>Name</th>
                    <th>Purpose</th>
                    <th>Access</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>R0-R12</td><td>General Purpose</td><td>Computation</td><td>Read/Write</td></tr>
                <tr><td>R13</td><td>%threadIdx</td><td>Thread index within block</td><td>Read-only</td></tr>
                <tr><td>R14</td><td>%blockDim</td><td>Block dimension</td><td>Read-only</td></tr>
                <tr><td>R15</td><td>%blockIdx</td><td>Block index within grid</td><td>Read-only</td></tr>
            </tbody>
        </table>

        <h2>5.3 Instruction Set Specification</h2>

        <h3>Arithmetic Instructions</h3>
        <table>
            <thead>
                <tr><th>Mnemonic</th><th>Opcode</th><th>Operation</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td><code>ADD</code></td><td>0x0</td><td>Rd = Rs1 + Rs2</td><td>32-bit integer addition</td></tr>
                <tr><td><code>SUB</code></td><td>0x1</td><td>Rd = Rs1 - Rs2</td><td>32-bit integer subtraction</td></tr>
                <tr><td><code>MUL</code></td><td>0x2</td><td>Rd = Rs1 * Rs2</td><td>32-bit multiplication (low 32 bits)</td></tr>
                <tr><td><code>SLT</code></td><td>0x3</td><td>Rd = (Rs1 &lt; Rs2) ? 1 : 0</td><td>Set less than (signed)</td></tr>
            </tbody>
        </table>

        <h3>Logical Instructions</h3>
        <table>
            <thead>
                <tr><th>Mnemonic</th><th>Opcode</th><th>Operation</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td><code>AND</code></td><td>0x4</td><td>Rd = Rs1 &amp; Rs2</td><td>Bitwise AND</td></tr>
                <tr><td><code>OR</code></td><td>0x5</td><td>Rd = Rs1 | Rs2</td><td>Bitwise OR</td></tr>
                <tr><td><code>XOR</code></td><td>0x6</td><td>Rd = Rs1 ^ Rs2</td><td>Bitwise XOR</td></tr>
            </tbody>
        </table>

        <h3>Memory Instructions</h3>
        <table>
            <thead>
                <tr><th>Mnemonic</th><th>Opcode</th><th>Operation</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td><code>LOAD</code></td><td>0x7</td><td>Rd = Memory[Rs1 + offset]</td><td>Load 32-bit word</td></tr>
                <tr><td><code>STORE</code></td><td>0x8</td><td>Memory[Rs1 + offset] = Rs2</td><td>Store 32-bit word</td></tr>
            </tbody>
        </table>

        <h3>Control Flow Instructions</h3>
        <table>
            <thead>
                <tr><th>Mnemonic</th><th>Opcode</th><th>Operation</th><th>Description</th></tr>
            </thead>
            <tbody>
                <tr><td><code>BRnzp</code></td><td>0x9</td><td>Branch if condition flags match</td><td>Conditional branch</td></tr>
                <tr><td><code>SYNC</code></td><td>0xA</td><td>Wait for all threads in block</td><td>Barrier synchronization</td></tr>
            </tbody>
        </table>

        <h3>Condition Flags</h3>
        <div class="figure">
            <div class="mermaid">
flowchart LR
    ALU["ALU Result"] --> FLAGS["Condition Flags"]
    
    FLAGS --> N["N (Negative)<br/>Result < 0"]
    FLAGS --> Z["Z (Zero)<br/>Result == 0"]
    FLAGS --> P["P (Positive)<br/>Result > 0"]
    
    N & Z & P --> BRANCH["BRnzp<br/>Branch Decision"]
    
    style FLAGS fill:#dbeafe,stroke:#3b82f6
            </div>
            <div class="figure-caption">Figure 5.4: Condition flags flow from ALU to branch decision</div>
        </div>

        <div class="code-block">
<pre>// Branch examples
SLT  R1, R2, R3   // Sets P flag if R2 < R3
BRnzp 0,0,1, 10   // Branch to PC+10 if P flag set

SUB  R1, R2, R3   // Sets Z flag if R2 == R3
BRnzp 0,1,0, 5    // Branch to PC+5 if Z flag set

BRnzp 1,1,1, -3   // Unconditional branch (loop back)</pre>
        </div>

        <h2>5.4 Instruction Encoding Details</h2>

        <div class="figure">
            <div class="mermaid">
flowchart TB
    subgraph ENCODE["Instruction Encoding Examples"]
        direction TB
        
        E1["ADD R1, R2, R3<br/>→ 0000 0001 0010 0011<br/>→ 0x0123"]
        E2["LOAD R7, R8, 4<br/>→ 0111 0111 1000 0100<br/>→ 0x7784"]
        E3["BRnzp z, 8<br/>→ 1001 0010 0000 1000<br/>→ 0x9208"]
    end
    
    style ENCODE fill:#f1f5f9,stroke:#64748b
            </div>
            <div class="figure-caption">Figure 5.5: Example instruction encodings</div>
        </div>

        <div class="code-block">
<pre>// Hardware decoder
module decoder (
    input [15:0] instruction,
    output [3:0] opcode,
    output [3:0] dst, src1, src2
);
    assign opcode = instruction[15:12];
    assign dst    = instruction[11:8];
    assign src1   = instruction[7:4];
    assign src2   = instruction[3:0];
endmodule</pre>
        </div>

        <h2>5.5 SIMT Execution of Instructions</h2>

        <div class="figure">
            <div class="mermaid">
flowchart LR
    subgraph WARP["Warp Execution (32 threads)"]
        direction TB
        T0["Thread 0: R1[0] = R2[0] + R3[0]"]
        T1["Thread 1: R1[1] = R2[1] + R3[1]"]
        T2["Thread 2: R1[2] = R2[2] + R3[2]"]
        TN["..."]
        T31["Thread 31: R1[31] = R2[31] + R3[31]"]
    end
    
    NOTE["All 32 ALUs execute<br/>in parallel!"]
    
    WARP --> NOTE
    
    style WARP fill:#dcfce7,stroke:#22c55e
            </div>
            <div class="figure-caption">Figure 5.6: SIMT execution of ADD across 32 threads in a warp</div>
        </div>

        <h2>5.6 Instruction Latency and Throughput</h2>

        <table>
            <thead>
                <tr>
                    <th>Instruction Type</th>
                    <th>Latency</th>
                    <th>Notes</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>ADD, SUB, AND, OR, XOR</td><td>1-2 cycles</td><td>Fast, single-cycle</td></tr>
                <tr><td>MUL (INT32)</td><td>3-4 cycles</td><td>Pipelined multiplier</td></tr>
                <tr><td>LOAD (L1 hit)</td><td>20-40 cycles</td><td>Cache access</td></tr>
                <tr><td>LOAD (L2 hit)</td><td>100-150 cycles</td><td>Off-chip cache</td></tr>
                <tr><td>LOAD (DRAM)</td><td>200-400 cycles</td><td>Main memory</td></tr>
            </tbody>
        </table>

        <div class="key-takeaway">
            <strong>Latency Hiding:</strong> GPUs hide memory latency by switching to other warps. 
            While one warp waits 200 cycles for LOAD, the scheduler executes 200 instructions from other warps!
        </div>

        <h2>5.7 Comparison with Real GPU ISAs</h2>

        <div class="figure">
            <div class="mermaid">
flowchart LR
    subgraph REAL["Real GPU ISAs"]
        direction TB
        PTX["NVIDIA PTX<br/>Virtual ISA → SASS"]
        GCN["AMD GCN/RDNA<br/>Native ISA"]
        RVV["RISC-V Vector<br/>Open standard"]
    end
    
    subgraph OURS["TinyGPU-ISA"]
        TINY["16-bit encoding<br/>11 instructions<br/>Educational"]
    end
    
    REAL --> |"Inspired"| OURS
    
    style REAL fill:#dbeafe,stroke:#3b82f6
    style OURS fill:#dcfce7,stroke:#22c55e
            </div>
            <div class="figure-caption">Figure 5.7: TinyGPU-ISA compared to real GPU ISAs</div>
        </div>

        <table>
            <thead>
                <tr><th>ISA</th><th>Vendor</th><th>Bits</th><th>Complexity</th><th>Openness</th></tr>
            </thead>
            <tbody>
                <tr><td>PTX</td><td>NVIDIA</td><td>Variable</td><td>High</td><td>Documented</td></tr>
                <tr><td>GCN/RDNA</td><td>AMD</td><td>32/64</td><td>Very high</td><td>Partial</td></tr>
                <tr><td>RISC-V RVV</td><td>Open</td><td>Variable</td><td>Medium</td><td>Fully open</td></tr>
                <tr><td>TinyGPU-ISA</td><td>Us!</td><td>16</td><td>Low</td><td>Fully open</td></tr>
            </tbody>
        </table>

        <h2>5.8 Practical Example: Vector Addition</h2>

        <div class="code-block">
<pre>// High-level kernel
__global__ void vectorAdd(int *A, int *B, int *C, int N) {
    int tid = blockIdx * blockDim + threadIdx;
    if (tid < N) {
        C[tid] = A[tid] + B[tid];
    }
}

// Compiled to TinyGPU-ISA:
MUL  R1, R15, R14       // R1 = blockIdx * blockDim
ADD  R2, R1, R13        // R2 = global thread ID
LOAD R3, R0, 0          // R3 = N
SLT  R4, R2, R3         // R4 = (tid < N)
BRnzp 0,1,0, EXIT       // if R4 == 0, goto EXIT
LOAD R5, R0, 1          // R5 = &A
ADD  R6, R5, R2         // R6 = &A[tid]
LOAD R7, R0, 2          // R7 = &B
ADD  R8, R7, R2         // R8 = &B[tid]
LOAD R9, R0, 3          // R9 = &C
ADD  R10, R9, R2        // R10 = &C[tid]
LOAD R11, R6, 0         // R11 = A[tid]
LOAD R12, R8, 0         // R12 = B[tid]
ADD  R1, R11, R12       // R1 = A[tid] + B[tid]
STORE R1, R10, 0        // C[tid] = R1
EXIT:</pre>
        </div>

        <div class="figure">
            <div class="mermaid">
flowchart TB
    subgraph KERNEL["Vector Addition Execution Flow"]
        TID["Compute Thread ID<br/>tid = blockIdx × blockDim + threadIdx"]
        BOUNDS["Bounds Check<br/>if tid < N"]
        LOAD_A["Load A[tid]"]
        LOAD_B["Load B[tid]"]
        ADD["Add: result = A + B"]
        STORE["Store C[tid]"]
        
        TID --> BOUNDS
        BOUNDS -->|Yes| LOAD_A
        BOUNDS -->|No| EXIT["Exit"]
        LOAD_A --> LOAD_B --> ADD --> STORE
    end
    
    style KERNEL fill:#f1f5f9,stroke:#64748b
            </div>
            <div class="figure-caption">Figure 5.8: Vector addition kernel execution flow</div>
        </div>

        <h2>5.9 Chapter Summary</h2>

        <ul>
            <li><strong>TinyGPU-ISA:</strong> 16-bit instructions, 16 registers, 11 operations</li>
            <li><strong>Instruction types:</strong> Arithmetic, Logical, Memory, Control flow</li>
            <li><strong>Register file:</strong> R0-R12 (GP), R13-R15 (special)</li>
            <li><strong>Encoding:</strong> OPCODE[15:12] | DST[11:8] | SRC1[7:4] | SRC2[3:0]</li>
            <li><strong>Condition flags:</strong> N/Z/P for branch decisions</li>
        </ul>

        <div class="key-takeaway">
            <strong>Next Steps:</strong> In Chapter 6, we'll design the pipeline that executes these instructions.
        </div>

        <div class="exercise">
            <strong>Exercise 5.1:</strong> Write TinyGPU-ISA assembly for: <code>int x = a * 2 + b; if (x > 100) x = 100;</code>
        </div>

        <div class="exercise">
            <strong>Exercise 5.2:</strong> Design encoding for <code>ADDI Rd, Rs, imm8</code> in 16 bits.
        </div>

        <div class="exercise">
            <strong>Exercise 5.3:</strong> Hand-compile a loop: <code>for (int i = 0; i < 10; i++) sum += array[i];</code>
        </div>

        <h2>Further Reading</h2>
        <ul>
            <li><a href="https://docs.nvidia.com/cuda/parallel-thread-execution/index.html">NVIDIA PTX ISA Reference</a></li>
            <li><a href="https://riscv.org/technical/specifications/">RISC-V Vector Extension Spec</a></li>
            <li>"Computer Organization and Design: RISC-V Edition" — ISA fundamentals</li>
        </ul>

        <div class="chapter-nav">
            <a href="chapter-04.html">← Previous: Core Components</a>
            <a href="../table-of-contents.html">Table of Contents</a>
            <a href="chapter-06.html">Next: Pipeline Design →</a>
        </div>
    </div>

    <script>
        mermaid.initialize({ 
            startOnLoad: true, 
            theme: 'base',
            themeVariables: {
                primaryColor: '#6366f1',
                primaryTextColor: '#1e293b',
                primaryBorderColor: '#4f46e5',
                lineColor: '#64748b',
                secondaryColor: '#10b981',
                tertiaryColor: '#f1f5f9'
            }
        });
    </script>
    <script src="../navigation.js"></script>
</body>
</html>
