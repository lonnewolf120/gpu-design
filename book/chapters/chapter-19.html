<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chapter 19: Advanced RTL Techniques | Create Your Own GPU</title>
    <link rel="stylesheet" href="../styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        .chapter-content { max-width: 900px; margin: 0 auto; padding: 40px 20px; }
        .code-block { background: #1e1e1e; color: #d4d4d4; padding: 20px; border-radius: 8px; overflow-x: auto; margin: 20px 0; font-family: 'Consolas', monospace; font-size: 13px; line-height: 1.5; }
        .code-block code { color: #d4d4d4; }
        .keyword { color: #569cd6; }
        .type { color: #4ec9b0; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; }
        .number { color: #b5cea8; }
        .key-takeaway { background: linear-gradient(135deg, #e8f4fd 0%, #f0f8ff 100%); border-left: 4px solid #2196f3; padding: 20px; margin: 24px 0; border-radius: 0 8px 8px 0; }
        .exercise { background: linear-gradient(135deg, #fff3e0 0%, #fffaf0 100%); border-left: 4px solid #ff9800; padding: 20px; margin: 24px 0; border-radius: 0 8px 8px 0; }
        .mermaid { background: white; padding: 20px; border-radius: 8px; border: 1px solid #e0e0e0; margin: 20px 0; text-align: center; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-radius: 8px; overflow: hidden; }
        th, td { border: 1px solid #e0e0e0; padding: 14px 16px; text-align: left; }
        th { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-weight: 600; }
        tr:nth-child(even) { background: #f8f9fa; }
        tr:hover { background: #f0f4ff; }
        .info-box { background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; padding: 16px; margin: 20px 0; }
        .warning-box { background: #fff8e1; border: 1px solid #ffc107; border-radius: 8px; padding: 16px; margin: 20px 0; }
        .danger-box { background: #ffebee; border: 1px solid #f44336; border-radius: 8px; padding: 16px; margin: 20px 0; }
        .nav-container { display: flex; justify-content: space-between; margin: 40px 0; padding: 20px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .nav-container a { text-decoration: none; color: #667eea; font-weight: 500; transition: color 0.3s; }
        .nav-container a:hover { color: #764ba2; }
        h2 { color: #333; border-bottom: 3px solid #667eea; padding-bottom: 10px; margin-top: 40px; }
        h3 { color: #555; margin-top: 30px; }
        .solution { background: #e8f5e9; border-left: 4px solid #4caf50; padding: 16px; margin-top: 16px; border-radius: 0 8px 8px 0; }
        .file-header { background: #2d2d2d; color: #9cdcfe; padding: 8px 16px; border-radius: 8px 8px 0 0; font-size: 12px; font-family: monospace; margin-bottom: -20px; }
        .comparison-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
        .comparison-box { background: #f5f5f5; padding: 16px; border-radius: 8px; }
        .comparison-box.good { border-left: 4px solid #4caf50; }
        .comparison-box.bad { border-left: 4px solid #f44336; }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="nav-container">
            <a href="chapter-18.html">‚Üê Previous: Multi-Core Design</a>
            <a href="../table-of-contents.html">Table of Contents</a>
            <a href="chapter-20.html">Next: Simulation and Debugging ‚Üí</a>
        </div>

        <h1>Chapter 19: Advanced RTL Techniques</h1>
        <div style="color: #666; margin: 20px 0; font-size: 0.95em;">
            <span style="background: #667eea; color: white; padding: 4px 12px; border-radius: 20px; margin-right: 10px;">Part IV: RTL Implementation</span>
            <span>Reading time: ~70 minutes</span>
        </div>

        <h2>Introduction</h2>
        <p>Writing correct RTL is only the first step. This chapter covers advanced techniques for writing maintainable, synthesizable, and high-performance SystemVerilog code. We'll explore pipelining, hazard handling, timing optimization, and common pitfalls to avoid.</p>

        <h2>19.1 Pipelining Fundamentals</h2>

        <p>Pipelining increases throughput by overlapping instruction execution stages:</p>

        <div class="mermaid">
gantt
    title Non-Pipelined vs Pipelined Execution
    dateFormat X
    axisFormat %s
    
    section Non-Pipelined
    Instr 1 (F-D-E-W)    :0, 4
    Instr 2 (F-D-E-W)    :4, 4
    Instr 3 (F-D-E-W)    :8, 4
    
    section Pipelined
    I1 Fetch     :0, 1
    I1 Decode    :1, 1
    I1 Execute   :2, 1
    I1 Write     :3, 1
    I2 Fetch     :1, 1
    I2 Decode    :2, 1
    I2 Execute   :3, 1
    I2 Write     :4, 1
    I3 Fetch     :2, 1
    I3 Decode    :3, 1
    I3 Execute   :4, 1
    I3 Write     :5, 1
        </div>

        <h3>19.1.1 tiny-gpu Pipeline</h3>

        <p>tiny-gpu uses a 6-stage pipeline without overlapping:</p>

        <div class="mermaid">
graph LR
    F["FETCH"] --> D["DECODE"] --> R["REQUEST"] --> W["WAIT"] --> E["EXECUTE"] --> U["UPDATE"]
    U -->|loop| F
    
    style F fill:#e3f2fd
    style D fill:#e3f2fd
    style R fill:#fff3e0
    style W fill:#fff3e0
    style E fill:#e8f5e9
    style U fill:#e8f5e9
        </div>

        <div class="info-box">
            <strong>üí° Design Simplicity:</strong> tiny-gpu processes one instruction at a time across all threads. While this simplifies hazard handling, it limits throughput. Production GPUs use deep pipelines with hazard detection.
        </div>

        <h3>19.1.2 Implementing a Pipelined ALU</h3>

        <div class="code-block">
<code><span class="comment">// Non-pipelined multiplier (single cycle)</span>
<span class="keyword">module</span> <span class="type">mult_single</span> (
    <span class="keyword">input</span> [7:0] a, b,
    <span class="keyword">output</span> [15:0] product
);
    <span class="keyword">assign</span> product = a * b;  <span class="comment">// Combinational - long critical path</span>
<span class="keyword">endmodule</span>

<span class="comment">// 2-stage pipelined multiplier</span>
<span class="keyword">module</span> <span class="type">mult_pipelined</span> (
    <span class="keyword">input</span> <span class="keyword">wire</span> clk,
    <span class="keyword">input</span> [7:0] a, b,
    <span class="keyword">output</span> <span class="keyword">reg</span> [15:0] product
);
    <span class="comment">// Stage 1: Partial products</span>
    <span class="keyword">reg</span> [15:0] pp_low, pp_high;
    
    <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span>
        pp_low  &lt;= a[3:0] * b;        <span class="comment">// 4-bit √ó 8-bit</span>
        pp_high &lt;= a[7:4] * b &lt;&lt; <span class="number">4</span>;  <span class="comment">// Shifted partial</span>
    <span class="keyword">end</span>
    
    <span class="comment">// Stage 2: Combine</span>
    <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span>
        product &lt;= pp_low + pp_high;
    <span class="keyword">end</span>
<span class="keyword">endmodule</span>
</code>
        </div>

        <h2>19.2 Hazard Detection and Resolution</h2>

        <p>Hazards occur when pipeline stages conflict:</p>

        <table>
            <thead>
                <tr><th>Hazard Type</th><th>Cause</th><th>Example</th><th>Resolution</th></tr>
            </thead>
            <tbody>
                <tr><td>Data Hazard (RAW)</td><td>Read-After-Write dependency</td><td>ADD R1,R2,R3; SUB R4,R1,R5</td><td>Forwarding or stall</td></tr>
                <tr><td>Control Hazard</td><td>Branch changes PC</td><td>BRnzp LABEL</td><td>Branch prediction, flush</td></tr>
                <tr><td>Structural Hazard</td><td>Resource conflict</td><td>Two loads, one memory port</td><td>Arbitration, stall</td></tr>
            </tbody>
        </table>

        <h3>19.2.1 Data Forwarding</h3>

        <div class="code-block">
<code><span class="comment">// Forwarding unit - provides most recent value</span>
<span class="keyword">module</span> <span class="type">forwarding_unit</span> (
    <span class="comment">// From decode stage</span>
    <span class="keyword">input</span> [3:0] rs_addr, rt_addr,
    
    <span class="comment">// From execute stage (previous instruction)</span>
    <span class="keyword">input</span> [3:0] ex_rd_addr,
    <span class="keyword">input</span> ex_reg_write,
    <span class="keyword">input</span> [7:0] ex_result,
    
    <span class="comment">// From writeback stage (2 instructions ago)</span>
    <span class="keyword">input</span> [3:0] wb_rd_addr,
    <span class="keyword">input</span> wb_reg_write,
    <span class="keyword">input</span> [7:0] wb_result,
    
    <span class="comment">// Forwarded values</span>
    <span class="keyword">output</span> <span class="keyword">reg</span> [1:0] forward_a, forward_b  <span class="comment">// 00=reg, 01=ex, 10=wb</span>
);
    <span class="keyword">always_comb</span> <span class="keyword">begin</span>
        <span class="comment">// RS forwarding</span>
        <span class="keyword">if</span> (ex_reg_write && ex_rd_addr == rs_addr)
            forward_a = <span class="number">2'b01</span>;  <span class="comment">// Forward from EX</span>
        <span class="keyword">else if</span> (wb_reg_write && wb_rd_addr == rs_addr)
            forward_a = <span class="number">2'b10</span>;  <span class="comment">// Forward from WB</span>
        <span class="keyword">else</span>
            forward_a = <span class="number">2'b00</span>;  <span class="comment">// Use register file</span>
            
        <span class="comment">// RT forwarding (similar logic)</span>
    <span class="keyword">end</span>
<span class="keyword">endmodule</span>
</code>
        </div>

        <h3>19.2.2 Pipeline Stalls</h3>

        <div class="code-block">
<code><span class="comment">// Stall detection for load-use hazard</span>
<span class="keyword">wire</span> load_use_hazard = ex_mem_read && 
                        ((ex_rd_addr == id_rs_addr) || (ex_rd_addr == id_rt_addr));

<span class="comment">// Stall signal freezes earlier stages</span>
<span class="keyword">wire</span> stall = load_use_hazard;

<span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span>
    <span class="keyword">if</span> (!stall) <span class="keyword">begin</span>
        id_instruction &lt;= if_instruction;
        if_pc &lt;= if_pc + <span class="number">1</span>;
    <span class="keyword">end</span>
    <span class="comment">// else: hold current values (stall)</span>
<span class="keyword">end</span>
</code>
        </div>

        <h2>19.3 Timing Optimization</h2>

        <h3>19.3.1 Critical Path Analysis</h3>

        <p>The critical path determines maximum clock frequency:</p>

        <div class="mermaid">
graph LR
    REG1["Register<br/>tclk-q"] --> COMB["Combinational<br/>Logic<br/>tlogic"] --> REG2["Register<br/>tsetup"]
    
    style REG1 fill:#e8f5e9
    style COMB fill:#fff3e0
    style REG2 fill:#e8f5e9
        </div>

        <p><strong>Maximum frequency:</strong> f<sub>max</sub> = 1 / (t<sub>clk-q</sub> + t<sub>logic</sub> + t<sub>setup</sub>)</p>

        <h3>19.3.2 Breaking Long Paths</h3>

        <div class="comparison-grid">
            <div class="comparison-box bad">
                <h4>‚ùå Long Combinational Path</h4>
                <pre><code>// 32-bit ripple-carry adder
assign sum = a + b + c + d;</code></pre>
                <p>Single cycle, slow frequency</p>
            </div>
            <div class="comparison-box good">
                <h4>‚úÖ Registered Intermediate</h4>
                <pre><code>// Split across two cycles
always_ff @(posedge clk) begin
    temp <= a + b;
    sum <= temp + c + d;
end</code></pre>
                <p>Two cycles, higher frequency</p>
            </div>
        </div>

        <h3>19.3.3 Retiming</h3>

        <div class="code-block">
<code><span class="comment">// Before retiming: Long path through multiplier and adder</span>
<span class="keyword">wire</span> [15:0] mult_result = a * b;
<span class="keyword">wire</span> [15:0] final_result = mult_result + c;

<span class="comment">// After retiming: Register between multiply and add</span>
<span class="keyword">reg</span> [15:0] mult_result_reg;
<span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk)
    mult_result_reg &lt;= a * b;

<span class="keyword">wire</span> [15:0] final_result = mult_result_reg + c;
</code>
        </div>

        <h2>19.4 FSM Best Practices</h2>

        <h3>19.4.1 Two-Process FSM Style</h3>

        <div class="code-block">
<code><span class="comment">// Style 1: Two-process FSM (recommended)</span>
<span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [2:0] {IDLE, FETCH, DECODE, EXECUTE} state_t;
state_t current_state, next_state;

<span class="comment">// Sequential: State register</span>
<span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span>
    <span class="keyword">if</span> (reset)
        current_state &lt;= IDLE;
    <span class="keyword">else</span>
        current_state &lt;= next_state;
<span class="keyword">end</span>

<span class="comment">// Combinational: Next state and outputs</span>
<span class="keyword">always_comb</span> <span class="keyword">begin</span>
    next_state = current_state;  <span class="comment">// Default: hold</span>
    mem_read = <span class="number">0</span>;                <span class="comment">// Default outputs</span>
    
    <span class="keyword">case</span> (current_state)
        IDLE: <span class="keyword">if</span> (start) next_state = FETCH;
        FETCH: <span class="keyword">begin</span>
            mem_read = <span class="number">1</span>;
            <span class="keyword">if</span> (mem_ready) next_state = DECODE;
        <span class="keyword">end</span>
        <span class="comment">// ...</span>
    <span class="keyword">endcase</span>
<span class="keyword">end</span>
</code>
        </div>

        <h3>19.4.2 One-Hot Encoding</h3>

        <div class="code-block">
<code><span class="comment">// Binary encoding: 3 bits for 6 states</span>
<span class="keyword">localparam</span> [2:0] IDLE = <span class="number">3'b000</span>,
                 FETCH = <span class="number">3'b001</span>,
                 DECODE = <span class="number">3'b010</span>,
                 EXECUTE = <span class="number">3'b011</span>;

<span class="comment">// One-hot encoding: 6 bits for 6 states (faster, more area)</span>
<span class="keyword">localparam</span> [5:0] IDLE    = <span class="number">6'b000001</span>,
                 FETCH   = <span class="number">6'b000010</span>,
                 DECODE  = <span class="number">6'b000100</span>,
                 REQUEST = <span class="number">6'b001000</span>,
                 EXECUTE = <span class="number">6'b010000</span>,
                 UPDATE  = <span class="number">6'b100000</span>;

<span class="comment">// One-hot state check is simpler</span>
<span class="keyword">wire</span> is_fetch = state[1];  <span class="comment">// Just bit test</span>
</code>
        </div>

        <h2>19.5 Common RTL Pitfalls</h2>

        <h3>19.5.1 Combinational Loops</h3>

        <div class="danger-box">
            <strong>üö´ Never create feedback without a register:</strong>
        </div>

        <div class="comparison-grid">
            <div class="comparison-box bad">
                <h4>‚ùå Combinational Loop</h4>
<pre><code>wire a;
assign a = b & ~a;  // Loop!</code></pre>
            </div>
            <div class="comparison-box good">
                <h4>‚úÖ Registered Feedback</h4>
<pre><code>reg a;
always_ff @(posedge clk)
    a <= b & ~a;</code></pre>
            </div>
        </div>

        <h3>19.5.2 Incomplete Sensitivity Lists</h3>

        <div class="comparison-grid">
            <div class="comparison-box bad">
                <h4>‚ùå Missing Signal</h4>
<pre><code>always @(a)  // Missing b!
    c = a & b;</code></pre>
            </div>
            <div class="comparison-box good">
                <h4>‚úÖ Use always_comb</h4>
<pre><code>always_comb
    c = a & b;  // Auto-sens</code></pre>
            </div>
        </div>

        <h3>19.5.3 Latch Inference</h3>

        <div class="comparison-grid">
            <div class="comparison-box bad">
                <h4>‚ùå Infers Latch</h4>
<pre><code>always_comb begin
    case (sel)
        2'b00: out = a;
        2'b01: out = b;
        // Missing 2'b10, 2'b11!
    endcase
end</code></pre>
            </div>
            <div class="comparison-box good">
                <h4>‚úÖ Default Case</h4>
<pre><code>always_comb begin
    case (sel)
        2'b00: out = a;
        2'b01: out = b;
        default: out = 8'b0;
    endcase
end</code></pre>
            </div>
        </div>

        <h3>19.5.4 Blocking vs Non-Blocking</h3>

        <div class="warning-box">
            <strong>‚ö†Ô∏è Rule of thumb:</strong>
            <ul>
                <li><code>&lt;=</code> (non-blocking) in always_ff for sequential logic</li>
                <li><code>=</code> (blocking) in always_comb for combinational logic</li>
            </ul>
        </div>

        <div class="comparison-grid">
            <div class="comparison-box bad">
                <h4>‚ùå Blocking in Sequential</h4>
<pre><code>always_ff @(posedge clk) begin
    a = b;  // Wrong!
    c = a;  // Gets new value of a
end</code></pre>
            </div>
            <div class="comparison-box good">
                <h4>‚úÖ Non-Blocking in Sequential</h4>
<pre><code>always_ff @(posedge clk) begin
    a <= b;
    c <= a;  // Gets old value of a
end</code></pre>
            </div>
        </div>

        <h2>19.6 Synthesis Attributes</h2>

        <div class="code-block">
<code><span class="comment">// Keep signal from being optimized away</span>
(* keep = <span class="string">"true"</span> *)
<span class="keyword">wire</span> debug_signal;

<span class="comment">// Force one-hot encoding for FSM</span>
(* fsm_encoding = <span class="string">"one_hot"</span> *)
<span class="keyword">reg</span> [3:0] state;

<span class="comment">// Mark as multicycle path</span>
(* multicycle = <span class="string">"2"</span> *)
<span class="keyword">wire</span> [31:0] slow_path;

<span class="comment">// Prevent register merging</span>
(* dont_merge *)
<span class="keyword">reg</span> [7:0] pipeline_reg;
</code>
        </div>

        <h2>19.7 Exercises</h2>

        <div class="exercise">
            <h4>Exercise 19.1: Identify the Hazard</h4>
            <p>What hazard exists in this code sequence, and how would you resolve it?</p>
            <pre><code>LDR R1, [R2]    // Load from memory
ADD R3, R1, R4  // Use R1 immediately</code></pre>
            
            <details>
                <summary><strong>Click to reveal solution</strong></summary>
                <div class="solution">
                    <p><strong>Hazard:</strong> Load-use data hazard (RAW). R1 isn't available until LDR completes.</p>
                    <p><strong>Solutions:</strong></p>
                    <ol>
                        <li>Insert a NOP (stall the pipeline)</li>
                        <li>Compiler reordering (move independent instruction between)</li>
                        <li>Hardware interlock (stall detection logic)</li>
                    </ol>
                </div>
            </details>
        </div>

        <div class="exercise">
            <h4>Exercise 19.2: Fix the Bug</h4>
            <p>What's wrong with this FSM, and how would you fix it?</p>
<pre><code>always_comb begin
    case (state)
        IDLE: if (start) next_state = RUN;
        RUN:  if (done)  next_state = IDLE;
    endcase
end</code></pre>
            
            <details>
                <summary><strong>Click to reveal solution</strong></summary>
                <div class="solution">
                    <p><strong>Bug:</strong> No default assignment for next_state. If conditions aren't met, next_state is undefined ‚Üí latch inference.</p>
<pre><code>always_comb begin
    next_state = state;  // Default: hold
    case (state)
        IDLE: if (start) next_state = RUN;
        RUN:  if (done)  next_state = IDLE;
        default: next_state = IDLE;  // Safety
    endcase
end</code></pre>
                </div>
            </details>
        </div>

        <h2>19.8 Key Takeaways</h2>

        <div class="key-takeaway">
            <p><strong>üéØ Pipelining trades latency for throughput:</strong> Each stage does less work, allowing higher clock frequency.</p>
        </div>

        <div class="key-takeaway">
            <p><strong>üîÑ Hazards require explicit handling:</strong> Forward, stall, or predict to maintain correctness.</p>
        </div>

        <div class="key-takeaway">
            <p><strong>‚ö° Critical path determines frequency:</strong> Break long combinational paths with pipeline registers.</p>
        </div>

        <div class="key-takeaway">
            <p><strong>üõ°Ô∏è Defensive coding prevents bugs:</strong> Use always_comb, default cases, and non-blocking assignments correctly.</p>
        </div>

        <div class="nav-container">
            <a href="chapter-18.html">‚Üê Previous: Multi-Core Design</a>
            <a href="../table-of-contents.html">Table of Contents</a>
            <a href="chapter-20.html">Next: Simulation and Debugging ‚Üí</a>
        </div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
    <script src="../navigation.js"></script>
</body>
</html>
