<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chapter 20: Simulation and Debugging | Create Your Own GPU</title>
    <link rel="stylesheet" href="../styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        .chapter-content { max-width: 900px; margin: 0 auto; padding: 40px 20px; }
        .code-block { background: #1e1e1e; color: #d4d4d4; padding: 20px; border-radius: 8px; overflow-x: auto; margin: 20px 0; font-family: 'Consolas', monospace; font-size: 13px; line-height: 1.5; }
        .code-block code { color: #d4d4d4; }
        .keyword { color: #569cd6; }
        .type { color: #4ec9b0; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; }
        .number { color: #b5cea8; }
        .decorator { color: #c586c0; }
        .key-takeaway { background: linear-gradient(135deg, #e8f4fd 0%, #f0f8ff 100%); border-left: 4px solid #2196f3; padding: 20px; margin: 24px 0; border-radius: 0 8px 8px 0; }
        .exercise { background: linear-gradient(135deg, #fff3e0 0%, #fffaf0 100%); border-left: 4px solid #ff9800; padding: 20px; margin: 24px 0; border-radius: 0 8px 8px 0; }
        .mermaid { background: white; padding: 20px; border-radius: 8px; border: 1px solid #e0e0e0; margin: 20px 0; text-align: center; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border-radius: 8px; overflow: hidden; }
        th, td { border: 1px solid #e0e0e0; padding: 14px 16px; text-align: left; }
        th { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-weight: 600; }
        tr:nth-child(even) { background: #f8f9fa; }
        tr:hover { background: #f0f4ff; }
        .info-box { background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; padding: 16px; margin: 20px 0; }
        .warning-box { background: #fff8e1; border: 1px solid #ffc107; border-radius: 8px; padding: 16px; margin: 20px 0; }
        .nav-container { display: flex; justify-content: space-between; margin: 40px 0; padding: 20px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .nav-container a { text-decoration: none; color: #667eea; font-weight: 500; transition: color 0.3s; }
        .nav-container a:hover { color: #764ba2; }
        h2 { color: #333; border-bottom: 3px solid #667eea; padding-bottom: 10px; margin-top: 40px; }
        h3 { color: #555; margin-top: 30px; }
        .solution { background: #e8f5e9; border-left: 4px solid #4caf50; padding: 16px; margin-top: 16px; border-radius: 0 8px 8px 0; }
        .file-header { background: #2d2d2d; color: #9cdcfe; padding: 8px 16px; border-radius: 8px 8px 0 0; font-size: 12px; font-family: monospace; margin-bottom: -20px; }
        .waveform { background: #1a1a2e; color: #0f0; padding: 20px; border-radius: 8px; font-family: monospace; margin: 20px 0; overflow-x: auto; }
        .waveform-signal { color: #4fc3f7; }
        .waveform-value { color: #aed581; }
    </style>
</head>
<body>
    <div class="chapter-content">
        <div class="nav-container">
            <a href="chapter-19.html">‚Üê Previous: Advanced RTL Techniques</a>
            <a href="../table-of-contents.html">Table of Contents</a>
            <a href="chapter-21.html">Next: Logic Synthesis ‚Üí</a>
        </div>

        <h1>Chapter 20: Simulation and Debugging</h1>
        <div style="color: #666; margin: 20px 0; font-size: 0.95em;">
            <span style="background: #667eea; color: white; padding: 4px 12px; border-radius: 20px; margin-right: 10px;">Part V: Verification & Tools</span>
            <span>Reading time: ~65 minutes</span>
        </div>

        <h2>Introduction</h2>
        <p>Simulation is how we verify that our GPU design works correctly before committing to silicon. This chapter covers the simulation toolchain used by tiny-gpu, waveform analysis, and debugging techniques for finding and fixing RTL bugs.</p>

        <h2>20.1 The Simulation Stack</h2>

        <div class="mermaid">
graph TB
    subgraph "Test Environment"
        TEST["Python Test<br/>(cocotb)"]
        MEM["Memory Model<br/>(memory.py)"]
    end
    
    subgraph "Simulation"
        SV2V["sv2v<br/>SV ‚Üí Verilog"]
        IVER["Icarus Verilog<br/>Compilation"]
        VVP["VVP<br/>Simulation"]
    end
    
    subgraph "Analysis"
        VCD["VCD Waveform"]
        GTK["GTKWave<br/>Viewer"]
    end
    
    TEST --> SV2V
    SV2V --> IVER
    IVER --> VVP
    VVP <--> MEM
    VVP --> VCD
    VCD --> GTK
    
    style TEST fill:#e3f2fd
    style VVP fill:#e8f5e9
    style GTK fill:#fff3e0
        </div>

        <h3>20.1.1 Tool Versions</h3>

        <table>
            <thead>
                <tr><th>Tool</th><th>Purpose</th><th>Installation</th></tr>
            </thead>
            <tbody>
                <tr><td>sv2v</td><td>SystemVerilog ‚Üí Verilog 2005 conversion</td><td><code>cargo install sv2v</code> or binary release</td></tr>
                <tr><td>Icarus Verilog</td><td>Open-source Verilog simulator</td><td><code>apt install iverilog</code></td></tr>
                <tr><td>cocotb</td><td>Python-based verification framework</td><td><code>pip install cocotb</code></td></tr>
                <tr><td>GTKWave</td><td>Waveform viewer</td><td><code>apt install gtkwave</code></td></tr>
            </tbody>
        </table>

        <h2>20.2 Running Tests</h2>

        <h3>20.2.1 Makefile Targets</h3>

        <div class="file-header">Makefile</div>
        <div class="code-block">
<code><span class="comment"># Run matrix addition test</span>
make test_matadd

<span class="comment"># Run matrix multiplication test</span>
make test_matmul

<span class="comment"># Clean build artifacts</span>
make clean
</code>
        </div>

        <h3>20.2.2 Build Process</h3>

        <div class="code-block">
<code><span class="comment"># Step 1: Convert SystemVerilog to Verilog 2005</span>
sv2v src/*.sv -w build/gpu.v

<span class="comment"># Step 2: Compile with Icarus Verilog (creates VVP executable)</span>
iverilog -o build/gpu.vvp -g2012 build/gpu.v

<span class="comment"># Step 3: Run simulation with cocotb</span>
cd test && python -m pytest test_matadd.py -v
</code>
        </div>

        <h2>20.3 cocotb Test Structure</h2>

        <h3>20.3.1 Test Anatomy</h3>

        <div class="file-header">test/test_matadd.py</div>
        <div class="code-block">
<code><span class="keyword">import</span> cocotb
<span class="keyword">from</span> cocotb.clock <span class="keyword">import</span> Clock
<span class="keyword">from</span> cocotb.triggers <span class="keyword">import</span> RisingEdge, ClockCycles

<span class="decorator">@cocotb.test()</span>
<span class="keyword">async def</span> <span class="type">test_matrix_addition</span>(dut):
    <span class="string">"""Test GPU performs matrix addition correctly."""</span>
    
    <span class="comment"># 1. Create clock (10ns period = 100MHz)</span>
    clock = Clock(dut.clk, <span class="number">10</span>, units=<span class="string">"ns"</span>)
    cocotb.start_soon(clock.start())
    
    <span class="comment"># 2. Initialize memory with program and data</span>
    program_mem = Memory(dut, <span class="string">"program"</span>)
    data_mem = Memory(dut, <span class="string">"data"</span>)
    
    <span class="comment"># Load kernel: C[i] = A[i] + B[i]</span>
    program_mem.load([
        <span class="number">0x7015</span>,  <span class="comment"># CONST R0, #15 (threadIdx register)</span>
        <span class="number">0x0101</span>,  <span class="comment"># LDR R1, R0 (A[threadIdx])</span>
        <span class="number">0x7210</span>,  <span class="comment"># CONST R2, #16 (offset to B)</span>
        <span class="number">0x1302</span>,  <span class="comment"># ADD R3, R0, R2 (addr of B[threadIdx])</span>
        <span class="number">0x0403</span>,  <span class="comment"># LDR R4, R3 (B[threadIdx])</span>
        <span class="number">0x1514</span>,  <span class="comment"># ADD R5, R1, R4 (A+B)</span>
        <span class="number">0x7220</span>,  <span class="comment"># CONST R2, #32 (offset to C)</span>
        <span class="number">0x1602</span>,  <span class="comment"># ADD R6, R0, R2 (addr of C[threadIdx])</span>
        <span class="number">0x1056</span>,  <span class="comment"># STR R5, R6</span>
        <span class="number">0xF000</span>,  <span class="comment"># RET</span>
    ])
    
    <span class="comment"># Initialize data: A[0-15] = 1-16, B[0-15] = 100-115</span>
    data_mem.load_range(<span class="number">0</span>, [i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)])
    data_mem.load_range(<span class="number">16</span>, [<span class="number">100</span>+i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>)])
    
    <span class="comment"># 3. Reset GPU</span>
    dut.reset.value = <span class="number">1</span>
    <span class="keyword">await</span> ClockCycles(dut.clk, <span class="number">5</span>)
    dut.reset.value = <span class="number">0</span>
    
    <span class="comment"># 4. Configure thread count and start</span>
    dut.device_control_write_enable.value = <span class="number">1</span>
    dut.device_control_data.value = <span class="number">16</span>  <span class="comment"># 16 threads</span>
    <span class="keyword">await</span> RisingEdge(dut.clk)
    dut.device_control_write_enable.value = <span class="number">0</span>
    
    dut.start.value = <span class="number">1</span>
    
    <span class="comment"># 5. Wait for completion</span>
    <span class="keyword">while not</span> dut.done.value:
        <span class="keyword">await</span> RisingEdge(dut.clk)
    
    <span class="comment"># 6. Verify results</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):
        expected = (i+<span class="number">1</span>) + (<span class="number">100</span>+i)  <span class="comment"># A[i] + B[i]</span>
        actual = data_mem.read(<span class="number">32</span>+i)
        <span class="keyword">assert</span> actual == expected, <span class="string">f"C[{i}] = {actual}, expected {expected}"</span>
</code>
        </div>

        <h3>20.3.2 Memory Model</h3>

        <div class="file-header">test/helpers/memory.py</div>
        <div class="code-block">
<code><span class="keyword">class</span> <span class="type">Memory</span>:
    <span class="string">"""Simulates external memory for cocotb tests."""</span>
    
    <span class="keyword">def</span> <span class="type">__init__</span>(self, dut, mem_type):
        self.dut = dut
        self.mem_type = mem_type
        self.data = {}
        
        <span class="comment"># Start coroutine to handle memory requests</span>
        cocotb.start_soon(self._handle_requests())
    
    <span class="keyword">async def</span> <span class="type">_handle_requests</span>(self):
        <span class="string">"""Monitor memory interface and respond to requests."""</span>
        <span class="keyword">while</span> <span class="keyword">True</span>:
            <span class="keyword">await</span> RisingEdge(self.dut.clk)
            
            <span class="comment"># Check each channel for valid requests</span>
            <span class="keyword">for</span> ch <span class="keyword">in</span> range(self.num_channels):
                <span class="keyword">if</span> self._get_read_valid(ch):
                    addr = self._get_read_address(ch)
                    self._set_read_data(ch, self.data.get(addr, <span class="number">0</span>))
                    self._set_read_ready(ch, <span class="number">1</span>)
                <span class="keyword">else</span>:
                    self._set_read_ready(ch, <span class="number">0</span>)
                    
                <span class="keyword">if</span> self._get_write_valid(ch):
                    addr = self._get_write_address(ch)
                    data = self._get_write_data(ch)
                    self.data[addr] = data
                    self._set_write_ready(ch, <span class="number">1</span>)
                <span class="keyword">else</span>:
                    self._set_write_ready(ch, <span class="number">0</span>)
    
    <span class="keyword">def</span> <span class="type">load</span>(self, data_list):
        <span class="string">"""Load data starting at address 0."""</span>
        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(data_list):
            self.data[i] = val
</code>
        </div>

        <h2>20.4 Waveform Analysis</h2>

        <h3>20.4.1 Generating VCD Files</h3>

        <div class="code-block">
<code><span class="comment">// Add to testbench or top-level module</span>
<span class="keyword">initial</span> <span class="keyword">begin</span>
    $dumpfile(<span class="string">"gpu_sim.vcd"</span>);
    $dumpvars(<span class="number">0</span>, gpu);  <span class="comment">// Dump all signals in gpu module</span>
<span class="keyword">end</span>
</code>
        </div>

        <h3>20.4.2 Reading Waveforms</h3>

        <p>A typical waveform trace shows signal values over time:</p>

        <div class="waveform">
<pre>
<span class="waveform-signal">clk        </span> ‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤‚ï±‚ï≤
<span class="waveform-signal">reset      </span> ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà________
<span class="waveform-signal">start      </span> ________‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
<span class="waveform-signal">core_state </span> <span class="waveform-value">IDLE</span>    <span class="waveform-value">FETCH</span>   <span class="waveform-value">DECODE</span>  <span class="waveform-value">REQ</span>
<span class="waveform-signal">instruction</span> <span class="waveform-value">0x0000</span>  <span class="waveform-value">0x7015</span>  <span class="waveform-value">0x7015</span>  <span class="waveform-value">0x7015</span>
<span class="waveform-signal">done       </span> ________________________
</pre>
        </div>

        <h3>20.4.3 Key Signals to Monitor</h3>

        <table>
            <thead>
                <tr><th>Signal Category</th><th>Signals</th><th>What to Look For</th></tr>
            </thead>
            <tbody>
                <tr><td>Control</td><td>core_state, start, done, reset</td><td>FSM transitions, stuck states</td></tr>
                <tr><td>Fetch</td><td>fetcher_state, instruction, current_pc</td><td>Correct instruction fetch</td></tr>
                <tr><td>Decode</td><td>decoded_* signals</td><td>Correct instruction parsing</td></tr>
                <tr><td>Memory</td><td>*_mem_read_valid/ready, *_mem_write_*</td><td>Handshake completion</td></tr>
                <tr><td>ALU</td><td>rs, rt, alu_out</td><td>Correct computation</td></tr>
                <tr><td>Registers</td><td>R0-R15 values</td><td>Register updates</td></tr>
            </tbody>
        </table>

        <h2>20.5 Common Debug Scenarios</h2>

        <h3>20.5.1 Stuck FSM</h3>

        <div class="warning-box">
            <strong>Symptom:</strong> core_state stays in WAIT forever.
            <br><br>
            <strong>Debug steps:</strong>
            <ol>
                <li>Check memory handshake: Is mem_read_valid high?</li>
                <li>Check mem_read_ready: Is memory responding?</li>
                <li>Check LSU state: Is it stuck in REQUESTING?</li>
            </ol>
        </div>

        <h3>20.5.2 Wrong Computation</h3>

        <div class="warning-box">
            <strong>Symptom:</strong> ALU output is incorrect.
            <br><br>
            <strong>Debug steps:</strong>
            <ol>
                <li>Trace rs and rt inputs to ALU</li>
                <li>Check decoded_alu_arithmetic_mux (correct operation?)</li>
                <li>Verify register file reads correct addresses</li>
            </ol>
        </div>

        <h3>20.5.3 Memory Corruption</h3>

        <div class="code-block">
<code><span class="comment"># Add debug prints to memory model</span>
<span class="keyword">def</span> <span class="type">_handle_write</span>(self, ch, addr, data):
    <span class="keyword">print</span>(<span class="string">f"[MEM] Write: addr={addr:02x} data={data:02x}"</span>)
    self.data[addr] = data
    
<span class="comment"># Check for unexpected addresses</span>
<span class="keyword">if</span> addr > <span class="number">64</span>:
    <span class="keyword">print</span>(<span class="string">f"[WARN] Write to unexpected addr {addr}"</span>)
</code>
        </div>

        <h2>20.6 Assertion-Based Verification</h2>

        <div class="code-block">
<code><span class="comment">// SystemVerilog assertions for verification</span>

<span class="comment">// Property: FSM should never enter invalid state</span>
<span class="keyword">property</span> valid_state;
    @(<span class="keyword">posedge</span> clk) <span class="keyword">disable iff</span> (reset)
    core_state inside {IDLE, FETCH, DECODE, REQUEST, WAIT, EXECUTE, UPDATE};
<span class="keyword">endproperty</span>
<span class="keyword">assert property</span> (valid_state) <span class="keyword">else</span> $error(<span class="string">"Invalid state!"</span>);

<span class="comment">// Property: mem_read_ready should come within 100 cycles</span>
<span class="keyword">property</span> mem_response_time;
    @(<span class="keyword">posedge</span> clk) <span class="keyword">disable iff</span> (reset)
    mem_read_valid |-> ##[1:100] mem_read_ready;
<span class="keyword">endproperty</span>
<span class="keyword">assert property</span> (mem_response_time) <span class="keyword">else</span> $error(<span class="string">"Memory timeout!"</span>);

<span class="comment">// Cover: Verify branch is taken at least once</span>
<span class="keyword">cover property</span> (@(<span class="keyword">posedge</span> clk) decoded_pc_mux == <span class="number">1</span>);
</code>
        </div>

        <h2>20.7 cocotb Debugging Tips</h2>

        <h3>20.7.1 Logging</h3>

        <div class="code-block">
<code><span class="keyword">import</span> logging

<span class="comment"># Configure logging level</span>
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

<span class="decorator">@cocotb.test()</span>
<span class="keyword">async def</span> <span class="type">test_with_logging</span>(dut):
    logger.info(<span class="string">"Starting test"</span>)
    
    <span class="keyword">for</span> cycle <span class="keyword">in</span> range(<span class="number">100</span>):
        <span class="keyword">await</span> RisingEdge(dut.clk)
        logger.debug(<span class="string">f"Cycle {cycle}: state={dut.core_state.value}"</span>)
        
        <span class="keyword">if</span> dut.done.value:
            logger.info(<span class="string">f"Completed in {cycle} cycles"</span>)
            <span class="keyword">break</span>
</code>
        </div>

        <h3>20.7.2 Signal Forcing</h3>

        <div class="code-block">
<code><span class="comment"># Force a signal to a specific value (for testing)</span>
dut.mem_read_ready.value = <span class="number">1</span>  <span class="comment"># Force memory ready</span>

<span class="comment"># Release the force</span>
dut.mem_read_ready.value = cocotb.binary.BinaryValue(<span class="string">"z"</span>)
</code>
        </div>

        <h3>20.7.3 Timeout Protection</h3>

        <div class="code-block">
<code><span class="keyword">from</span> cocotb.triggers <span class="keyword">import</span> Timer, First

<span class="decorator">@cocotb.test()</span>
<span class="keyword">async def</span> <span class="type">test_with_timeout</span>(dut):
    <span class="comment"># Wait for done OR timeout</span>
    timeout = Timer(<span class="number">10</span>, units=<span class="string">"us"</span>)
    done_trigger = RisingEdge(dut.done)
    
    result = <span class="keyword">await</span> First(done_trigger, timeout)
    
    <span class="keyword">if</span> result == timeout:
        <span class="keyword">raise</span> cocotb.result.TestFailure(<span class="string">"Test timed out!"</span>)
</code>
        </div>

        <h2>20.8 Exercises</h2>

        <div class="exercise">
            <h4>Exercise 20.1: Add Debug Signal</h4>
            <p>The core doesn't expose the current PC externally. Modify core.sv to add a debug output showing current_pc. Write a cocotb test that logs the PC after each instruction.</p>
            
            <details>
                <summary><strong>Click to reveal solution</strong></summary>
                <div class="solution">
                    <p>In core.sv, add output port:</p>
<pre><code>output wire [7:0] debug_pc,
// ...
assign debug_pc = current_pc;</code></pre>
                    <p>In test:</p>
<pre><code>while not dut.done.value:
    if dut.core_state.value == UPDATE:
        print(f"PC: {dut.debug_pc.value}")
    await RisingEdge(dut.clk)</code></pre>
                </div>
            </details>
        </div>

        <div class="exercise">
            <h4>Exercise 20.2: Write a Memory Test</h4>
            <p>Write a cocotb test that verifies a simple load/store sequence: store value 42 to address 0x10, then load it back and verify.</p>
            
            <details>
                <summary><strong>Click to reveal solution</strong></summary>
                <div class="solution">
<pre><code>@cocotb.test()
async def test_load_store(dut):
    program = [
        0x7001,  # CONST R0, 1  (value = 1, but use thread 0's ID which is 0)
        0x702A,  # CONST R0, 42 (value to store)
        0x7110,  # CONST R1, 16 (address 0x10)
        0x1001,  # STR R0, R1   (store 42 at 0x10)
        0x0201,  # LDR R2, R1   (load from 0x10)
        0xF000,  # RET
    ]
    # ... setup and run ...
    assert data_mem.read(0x10) == 42</code></pre>
                </div>
            </details>
        </div>

        <h2>20.9 Key Takeaways</h2>

        <div class="key-takeaway">
            <p><strong>üéØ cocotb bridges Python and RTL:</strong> Write tests in Python, simulate in Verilog. Best of both worlds.</p>
        </div>

        <div class="key-takeaway">
            <p><strong>üîç Waveforms are essential:</strong> When tests fail, examine signal transitions cycle-by-cycle.</p>
        </div>

        <div class="key-takeaway">
            <p><strong>‚è±Ô∏è Memory handshakes are common bugs:</strong> Always verify valid/ready protocol completion.</p>
        </div>

        <div class="key-takeaway">
            <p><strong>üõ°Ô∏è Assertions catch bugs early:</strong> Add properties for invariants, timing, and coverage.</p>
        </div>

        <div class="nav-container">
            <a href="chapter-19.html">‚Üê Previous: Advanced RTL Techniques</a>
            <a href="../table-of-contents.html">Table of Contents</a>
            <a href="chapter-21.html">Next: Logic Synthesis ‚Üí</a>
        </div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
    <script src="../navigation.js"></script>
</body>
</html>
